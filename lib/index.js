// Generated by CoffeeScript 1.9.2
var OpenGraph, _, async, cheerio, iconv, request, u,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

cheerio = require('cheerio');

_ = require('underscore');

request = require('request');

iconv = require('iconv-lite');

async = require('async');

u = require('url');

OpenGraph = (function() {
  var ALLOWED_CONTENT_TYPES, getEncoding;

  ALLOWED_CONTENT_TYPES = ['text/html', 'image/png', 'image/jpeg', 'image/jpg'];

  function OpenGraph(options) {
    if (options == null) {
      options = {};
    }
    this.getMetaFromBuffer = bind(this.getMetaFromBuffer, this);
    this.getMetaFromUrl = bind(this.getMetaFromUrl, this);
    this.isTld = bind(this.isTld, this);
    this.options = _.defaults(options, {
      parseFlat: true,
      encoding: null,
      followRedirect: true,
      followAllRedirects: false,
      maxRedirects: 3,
      timeout: 15 * 1000,
      gzip: true,
      headers: {
        'User-Agent': "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.104 Safari/537.36"
      },
      pool: {
        maxSockets: Infinity
      },
      onlyIanaTld: true
    });
    this.extractors = [];
    this.tlds = [];
    if (this.options.onlyIanaTld) {
      async.whilst((function(_this) {
        return function() {
          return _this.tlds.length === 0;
        };
      })(this), (function(_this) {
        return function(cb) {
          return request.get("http://data.iana.org/TLD/tlds-alpha-by-domain.txt", function(err, res, data) {
            var e, i, len, line, lines;
            if (err || res.statusCode !== 200) {
              return setTimeout(cb, 15 * 1000);
            }
            console.log('in');
            try {
              lines = data.split("\n");
              for (i = 0, len = lines.length; i < len; i++) {
                line = lines[i];
                if (line.length === 0) {
                  continue;
                }
                if (/^\t#/.test(line)) {
                  continue;
                }
                _this.tlds.push(line.toLowerCase());
              }
              return cb(null);
            } catch (_error) {
              e = _error;
              return setTimeout(cb, 15 * 1000);
            }
          });
        };
      })(this), function() {});
    }
    if (this.options.followRedirect && this.options.onlyIanaTld) {
      this.options.followRedirect = (function(_this) {
        return function(request) {
          var location;
          location = request.headers['location'];
          return _this.isTld(location);
        };
      })(this);
    }
  }

  OpenGraph.prototype.registerExtractor = function(extractor) {
    var ref1;
    if (!(extractor && _.isString(extractor.name) && extractor.name.length && _.isFunction(extractor.extract))) {
      throw new Error("Bad extractor format!");
    }
    if (ref1 = extractor.name, indexOf.call(_.pluck(this.extractors, 'name'), ref1) >= 0) {
      throw new Error("Extractor name duplication: " + extractor.name);
    }
    return this.extractors.push(extractor);
  };

  getEncoding = function(header) {
    var declaration, declarations, i, key, len, ref1, value;
    try {
      declarations = header.split(';');
      for (i = 0, len = declarations.length; i < len; i++) {
        declaration = declarations[i];
        ref1 = declaration.split('='), key = ref1[0], value = ref1[1];
        key = (function() {
          try {
            return key.replace(/\s/g, '');
          } catch (_error) {}
        })();
        value = (function() {
          try {
            return value.replace(/\s/g, '');
          } catch (_error) {}
        })();
        if (key && key.toLowerCase() === 'charset') {
          return value;
        }
      }
    } catch (_error) {}
    return null;
  };

  OpenGraph.prototype.isTld = function(url) {
    var hostname, tld;
    hostname = u.parse(url).hostname;
    if (!hostname) {
      return false;
    }
    tld = hostname.split(".").pop();
    return indexOf.call(this.tlds, tld) >= 0;
  };

  OpenGraph.prototype.getMetaFromUrl = function(url, callback) {
    var openGraphResponseHandler, theRequest;
    callback = _.once(callback);
    if (this.options.onlyIanaTld) {
      if (!this.isTld(url)) {
        return callback("wrong uri");
      }
    }
    theRequest = request.get(_.extend({
      url: url
    }, this.options), (function(_this) {
      return function(err, res, body) {
        if (theRequest) {
          theRequest.removeAllListeners('response');
        }
        if (err) {
          return callback(err);
        }
        if (Buffer.isBuffer(body)) {
          return _this.getMetaFromBuffer(body, res, callback);
        } else {
          return _this.getMetaFromHtml(body, res, callback);
        }
      };
    })(this));
    return theRequest.once('response', openGraphResponseHandler = function(res) {
      var contentDisposition, contentLength, contentType, ref1;
      contentDisposition = res.headers['content-disposition'];
      contentType = res.headers['content-type'] || '';
      contentType = contentType.split(';')[0];
      contentLength = res.headers['content-length'];
      if (res.statusCode >= 400) {
        theRequest.abort();
        return callback("status code " + res.statusCode + ", aborted");
      }
      if (contentDisposition && /^attachment/.test(contentDisposition)) {
        theRequest.abort();
        return callback("downloadable content, aborted");
      }
      if (ref1 = contentType.toLowerCase(), indexOf.call(ALLOWED_CONTENT_TYPES, ref1) < 0) {
        theRequest.abort();
        return callback("bad content type, aborted");
      }
      if (contentLength && parseInt(contentLength, 10) > 10 * 1024 * 1024) {
        theRequest.abort();
        return callback("response size over 10M, aborted");
      }
    });
  };

  OpenGraph.prototype.getMetaFromBuffer = function(buffer, res, callback) {
    var $, asciiHtml, e, encoding, html, i, len, metaTag, metaTags, ref1;
    if (!callback) {
      callback = res;
    }
    asciiHtml = buffer.toString('ascii');
    $ = (function() {
      try {
        return cheerio.load(asciiHtml);
      } catch (_error) {
        e = _error;
      }
    })();
    if (e) {
      return callback(e);
    }
    encoding = (function() {
      try {
        return getEncoding(res.headers['content-type']);
      } catch (_error) {}
    })();
    if (!encoding) {
      metaTags = (function() {
        try {
          return $('meta[http-equiv]');
        } catch (_error) {
          e = _error;
        }
      })();
      if (e) {
        return callback(e);
      }
      for (i = 0, len = metaTags.length; i < len; i++) {
        metaTag = metaTags[i];
        if (metaTag.attribs['http-equiv'].toLowerCase() === 'content-type') {
          encoding = getEncoding(metaTag.attribs.content);
        }
      }
    }
    if (encoding == null) {
      encoding = "utf-8";
    }
    if ((ref1 = encoding.toLowerCase()) === 'utf-8' || ref1 === 'utf8' || ref1 === null) {
      encoding = 'utf-8';
    }
    try {
      html = iconv.decode(buffer, encoding);
    } catch (_error) {
      e = _error;
      return callback(e);
    }
    return this.getMetaFromHtml(html, res, callback);
  };

  OpenGraph.prototype.getMetaFromHtml = function(html, res, callback) {
    var $, attrName, attrValue, createTree, e, i, len, meta, metaTags, namespace, parsed, properties, property;
    if (!callback) {
      callback = res;
    }
    parsed = {
      og: {},
      custom: {}
    };
    $ = (function() {
      try {
        return cheerio.load(html);
      } catch (_error) {
        e = _error;
      }
    })();
    if (e) {
      return callback(e);
    }
    namespace = null;
    html = (function() {
      try {
        return $('html')[0];
      } catch (_error) {}
    })();
    if (html != null ? html.attribs : void 0) {
      for (attrName in html.attribs) {
        attrValue = html.attribs[attrName];
        if (attrValue.toLowerCase() === 'http://opengraphprotocol.org/schema/' && attrName.substring(0, 6) === 'xmlns:') {
          namespace = attrName.substring(6);
          break;
        }
      }
    }
    if (namespace == null) {
      namespace = 'og';
    }
    namespace += ':';
    metaTags = (function() {
      try {
        return $("meta");
      } catch (_error) {
        e = _error;
      }
    })();
    if (e) {
      return callback(e);
    }
    for (i = 0, len = metaTags.length; i < len; i++) {
      meta = metaTags[i];
      properties = _.pick(meta.attribs, 'property', 'content');
      if (!(properties.property && properties.property.substring(0, namespace.length) === namespace)) {
        continue;
      }
      property = properties.property.substring(namespace.length);
      if (this.options.parseFlat) {
        if (_.isArray(parsed.og[property])) {
          parsed.og[property].push(properties.content);
        } else if (parsed.og[property]) {
          parsed.og[property] = [parsed.og[property], properties.content];
        } else {
          parsed.og[property] = properties.content;
        }
      } else {
        createTree = function(ref, keys) {
          var key, obj;
          key = keys.shift();
          if (keys.length) {
            if (_.isString(ref[key])) {
              ref[key] = [
                {
                  __root: ref[key]
                }
              ];
            } else {
              if (ref[key] == null) {
                ref[key] = [];
              }
            }
          } else {
            if (_.isArray(ref) && !ref.length) {
              obj = {};
              obj[key] = properties.content;
              ref.push(obj);
            } else if (_.isArray(ref) && !ref[ref.length - 1][key]) {
              ref[ref.length - 1][key] = properties.content;
            } else if (_.isArray(ref) && ref[ref.length - 1][key]) {
              obj = {};
              obj[key] = properties.content;
              ref.push(obj);
            } else if (_.isArray(ref[key])) {
              ref[key].push({
                __root: properties.content
              });
            } else {
              ref[key] = properties.content;
            }
          }
          if (keys.length) {
            return createTree(ref[key], keys);
          }
        };
        createTree(parsed.og, property.split(":"));
      }
    }
    return async.each(this.extractors, function(extractor, next) {
      try {
        return extractor.extract($, res, function(err, value) {
          if (err) {
            return next(err);
          }
          if (value) {
            parsed.custom[extractor.name] = value;
          }
          return setImmediate(function() {
            return next(null);
          });
        });
      } catch (_error) {
        e = _error;
        return setImmediate(function() {
          return next("extractor " + extractor.name + " thrown: " + e);
        });
      }
    }, function(error) {
      return callback(error, parsed);
    });
  };

  return OpenGraph;

})();

OpenGraph.extractors = require('./extractors');

module.exports = OpenGraph;
